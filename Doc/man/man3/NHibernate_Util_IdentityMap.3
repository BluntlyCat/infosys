.TH "NHibernate.Util.IdentityMap" 3 "Fri Jul 5 2013" "Version 1.0" "HSA.InfoSys" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NHibernate.Util.IdentityMap \- 
.PP
An IDictionary where keys are compared by object identity, rather than \fCequals\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits IDictionary, and IDeserializationCallback\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBAdd\fP (object key, object val)"
.br
.RI "\fIIDictionary\&.Add \fP"
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "\fIIDictionary\&.Clear \fP"
.ti -1c
.RI "bool \fBContains\fP (object key)"
.br
.RI "\fIIDictionary\&.Contains \fP"
.ti -1c
.RI "IDictionaryEnumerator \fBGetEnumerator\fP ()"
.br
.RI "\fIIDictionary\&.GetEnumerator \fP"
.ti -1c
.RI "void \fBRemove\fP (object key)"
.br
.RI "\fIIDictionary\&.Remove \fP"
.ti -1c
.RI "void \fBCopyTo\fP (Array array, int i)"
.br
.RI "\fIICollection\&.CopyTo \fP"
.ti -1c
.RI "void \fBOnDeserialization\fP (object sender)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static IDictionary \fBInstantiate\fP (int size)"
.br
.RI "\fICreate a new instance of the \fBIdentityMap\fP that has no iteration order\&. \fP"
.ti -1c
.RI "static IDictionary \fBInstantiateSequenced\fP (int size)"
.br
.RI "\fICreate a new instance of the \fBIdentityMap\fP that has an iteration order of the order the objects were added to the Map\&. \fP"
.ti -1c
.RI "static ICollection \fBConcurrentEntries\fP (IDictionary map)"
.br
.RI "\fIReturn the Dictionary Entries (as instances of \fCDictionaryEntry\fP in a collection that is safe from concurrent modification)\&. Ie - we may safely add new instances to the underlying \fCIDictionary\fP during enumeration of the \fCValues\fP\&. \fP"
.ti -1c
.RI "static ICollection \fBEntries\fP (IDictionary map)"
.br
.ti -1c
.RI "static IDictionary \fBInvert\fP (IDictionary map)"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "int \fBCount\fP\fC [get]\fP"
.br
.RI "\fIICollection\&.Count \fP"
.ti -1c
.RI "bool \fBIsSynchronized\fP\fC [get]\fP"
.br
.RI "\fIICollection\&.IsSynchronized \fP"
.ti -1c
.RI "object \fBSyncRoot\fP\fC [get]\fP"
.br
.RI "\fIICollection\&.SyncRoot \fP"
.ti -1c
.RI "bool \fBIsFixedSize\fP\fC [get]\fP"
.br
.RI "\fIIDictionary\&.IsFixedSize \fP"
.ti -1c
.RI "bool \fBIsReadOnly\fP\fC [get]\fP"
.br
.RI "\fIIDictionary\&.IsReadOnly \fP"
.ti -1c
.RI "ICollection \fBKeys\fP\fC [get]\fP"
.br
.RI "\fIReturns the Keys used in this \fBIdentityMap\fP IDictionary\&.IsReadOnly \fP"
.ti -1c
.RI "object \fBthis[object key]\fP\fC [get, set]\fP"
.br
.RI "\fIIDictionary\&.this \fP"
.ti -1c
.RI "ICollection \fBValues\fP\fC [get]\fP"
.br
.RI "\fIIDictionary\&.Values \fP"
.ti -1c
.RI "IList \fBEntryList\fP\fC [get]\fP"
.br
.RI "\fIProvides a snapshot VIEW in the form of a List of the contents of the \fBIdentityMap\fP\&. You can safely iterate over this VIEW and modify the actual \fBIdentityMap\fP because the VIEW is a copy of the contents, not a reference to the existing Map\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
An IDictionary where keys are compared by object identity, rather than \fCequals\fP\&. 

All external users of this class need to have no knowledge of the IdentityKey - it is all hidden by this class\&. 
.PP
Do NOT use a System\&.Value type as the key for this Hashtable - only classes\&. See the \fCgoogle thread\fP about why using System\&.Value is a bad thing\&. 
.PP
If I understand it correctly, the first call to get an object defined by a DateTime('2003-01-01') would box the DateTime and return the identity key for the box\&. If you were to get that Key and unbox it into a DateTime struct, then the next time you passed it in as the Key the \fBIdentityMap\fP would box it again (into a different box) and it would have a different IdentityKey - so you would not get the same value for the same DateTime value\&. 
.PP
Definition at line 30 of file IdentityMap\&.cs\&.
.SH "Member Function Documentation"
.PP 
.SS "void NHibernate\&.Util\&.IdentityMap\&.Add (objectkey, objectval)"

.PP
IDictionary\&.Add 
.PP
Definition at line 112 of file IdentityMap\&.cs\&.
.SS "void NHibernate\&.Util\&.IdentityMap\&.Clear ()"

.PP
IDictionary\&.Clear 
.PP
Definition at line 120 of file IdentityMap\&.cs\&.
.SS "static ICollection NHibernate\&.Util\&.IdentityMap\&.ConcurrentEntries (IDictionarymap)\fC [static]\fP"

.PP
Return the Dictionary Entries (as instances of \fCDictionaryEntry\fP in a collection that is safe from concurrent modification)\&. Ie - we may safely add new instances to the underlying \fCIDictionary\fP during enumeration of the \fCValues\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fImap\fP The IDictionary to get the enumeration safe list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A \fBCollection\fP of DictionaryEntries
.RE
.PP

.PP
Definition at line 64 of file IdentityMap\&.cs\&.
.SS "bool NHibernate\&.Util\&.IdentityMap\&.Contains (objectkey)"

.PP
IDictionary\&.Contains 
.PP
Definition at line 128 of file IdentityMap\&.cs\&.
.SS "void NHibernate\&.Util\&.IdentityMap\&.CopyTo (Arrayarray, inti)"

.PP
ICollection\&.CopyTo 
.PP
\fBParameters:\fP
.RS 4
\fIarray\fP 
.br
\fIi\fP 
.RE
.PP

.PP
Definition at line 213 of file IdentityMap\&.cs\&.
.SS "IDictionaryEnumerator NHibernate\&.Util\&.IdentityMap\&.GetEnumerator ()"

.PP
IDictionary\&.GetEnumerator 
.PP
Definition at line 145 of file IdentityMap\&.cs\&.
.SS "static IDictionary NHibernate\&.Util\&.IdentityMap\&.Instantiate (intsize)\fC [static]\fP"

.PP
Create a new instance of the \fBIdentityMap\fP that has no iteration order\&. 
.PP
\fBReturns:\fP
.RS 4
A new \fBIdentityMap\fP based on a Hashtable\&.
.RE
.PP

.PP
Definition at line 41 of file IdentityMap\&.cs\&.
.SS "static IDictionary NHibernate\&.Util\&.IdentityMap\&.InstantiateSequenced (intsize)\fC [static]\fP"

.PP
Create a new instance of the \fBIdentityMap\fP that has an iteration order of the order the objects were added to the Map\&. 
.PP
\fBReturns:\fP
.RS 4
A new \fBIdentityMap\fP based on ListDictionary\&.
.RE
.PP

.PP
Definition at line 52 of file IdentityMap\&.cs\&.
.SS "void NHibernate\&.Util\&.IdentityMap\&.Remove (objectkey)"

.PP
IDictionary\&.Remove 
.PP
Definition at line 178 of file IdentityMap\&.cs\&.
.SH "Property Documentation"
.PP 
.SS "int NHibernate\&.Util\&.IdentityMap\&.Count\fC [get]\fP"

.PP
ICollection\&.Count 
.PP
Definition at line 89 of file IdentityMap\&.cs\&.
.SS "IList NHibernate\&.Util\&.IdentityMap\&.EntryList\fC [get]\fP"

.PP
Provides a snapshot VIEW in the form of a List of the contents of the \fBIdentityMap\fP\&. You can safely iterate over this VIEW and modify the actual \fBIdentityMap\fP because the VIEW is a copy of the contents, not a reference to the existing Map\&. Contains a copy (not that actual instance stored) of the DictionaryEntries in a List\&. 
.PP
Definition at line 226 of file IdentityMap\&.cs\&.
.SS "bool NHibernate\&.Util\&.IdentityMap\&.IsFixedSize\fC [get]\fP"

.PP
IDictionary\&.IsFixedSize 
.PP
Definition at line 154 of file IdentityMap\&.cs\&.
.SS "bool NHibernate\&.Util\&.IdentityMap\&.IsReadOnly\fC [get]\fP"

.PP
IDictionary\&.IsReadOnly 
.PP
Definition at line 162 of file IdentityMap\&.cs\&.
.SS "bool NHibernate\&.Util\&.IdentityMap\&.IsSynchronized\fC [get]\fP"

.PP
ICollection\&.IsSynchronized 
.PP
Definition at line 97 of file IdentityMap\&.cs\&.
.SS "ICollection NHibernate\&.Util\&.IdentityMap\&.Keys\fC [get]\fP"

.PP
Returns the Keys used in this \fBIdentityMap\fP IDictionary\&.IsReadOnly 
.PP
Definition at line 171 of file IdentityMap\&.cs\&.
.SS "object NHibernate\&.Util\&.IdentityMap\&.SyncRoot\fC [get]\fP"

.PP
ICollection\&.SyncRoot 
.PP
Definition at line 105 of file IdentityMap\&.cs\&.
.SS "object NHibernate\&.Util\&.IdentityMap\&.this[object key]\fC [get]\fP, \fC [set]\fP"

.PP
IDictionary\&.this 
.PP
Definition at line 188 of file IdentityMap\&.cs\&.
.SS "ICollection NHibernate\&.Util\&.IdentityMap\&.Values\fC [get]\fP"

.PP
IDictionary\&.Values 
.PP
Definition at line 203 of file IdentityMap\&.cs\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for HSA\&.InfoSys from the source code\&.
