<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="COUNTDOWN_SET_NEW_CONFIG" xml:space="preserve">
    <value>Change settings {0} =&gt; {1} for job {2}.</value>
  </data>
  <data name="COUNTDOWN_TO_STRING" xml:space="preserve">
    <value>Countdown time: [{0}], source: [{1}]</value>
  </data>
  <data name="CRAWL_CONTROLLER_CLIENT_TO_STRING" xml:space="preserve">
    <value>Crawl client {0}, usable {1}, crawling {2}, URLs: [{3}], URL path: {4}, seed file {5}, command {6}.</value>
  </data>
  <data name="CRAWL_CONTROLLER_SHUTDOWN" xml:space="preserve">
    <value>Shutdown Services.</value>
  </data>
  <data name="CRAWL_CONTROLLER_START" xml:space="preserve">
    <value>Start crawl controller</value>
  </data>
  <data name="DBMANAGER_ADD_ENTITY" xml:space="preserve">
    <value>Instance of type {0} saved successfully in database.</value>
  </data>
  <data name="DBMANAGER_BYTEAMOUNT_GREATER_THAN_MAX_BYTES" xml:space="preserve">
    <value>Byte amount {0} &gt; maxbytes {1} at index {2}</value>
  </data>
  <data name="DBMANAGER_CREATE_COMPONENT" xml:space="preserve">
    <value>New component [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_ORGUNIT" xml:space="preserve">
    <value>New org unit [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_ORGUNITCONFIG" xml:space="preserve">
    <value>New org unit configuration [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_RESULT" xml:space="preserve">
    <value>New result [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_SCHEDULER" xml:space="preserve">
    <value>New scheduler [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_SOURCE" xml:space="preserve">
    <value>New source [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_SYSTEMSERVICE" xml:space="preserve">
    <value>New systemservice [{0}] created.</value>
  </data>
  <data name="DBMANAGER_DELETE_ENTITY" xml:space="preserve">
    <value>Deleted entity [{0}]</value>
  </data>
  <data name="DBMANAGER_EAGER_LOAD_THIS_ENTITIES" xml:space="preserve">
    <value>Load this entities [{0}] eager from database.</value>
  </data>
  <data name="DBMANAGER_GET_COMPONENT_BY_ORGUNIT_ID" xml:space="preserve">
    <value>Got components: [{0}] by GUID: [{1}].</value>
  </data>
  <data name="DBMANAGER_GET_ENTITY" xml:space="preserve">
    <value>Got entity of type [{0}] with values [{1}] by GUID [{2}]</value>
  </data>
  <data name="DBMANAGER_GET_ORGUNIT_BY_USERID" xml:space="preserve">
    <value>Got org unit [{0}] by id [{1}]</value>
  </data>
  <data name="DBMANAGER_GET_RESULTS_BY_COMPONENT_ID" xml:space="preserve">
    <value>Got results: [{0}] by GUID: [{1}].</value>
  </data>
  <data name="DBMANAGER_INCREASE_REQUEST_AMOUNT" xml:space="preserve">
    <value>Increase request amount.</value>
  </data>
  <data name="DBMANAGER_NO_MANAGER_FOUND" xml:space="preserve">
    <value>DBManager does not exist, create one.</value>
  </data>
  <data name="DBMANAGER_RESULTS_BYTE_COUNT" xml:space="preserve">
    <value>Total byte count of results: {0}</value>
  </data>
  <data name="DBMANAGER_SPLITTED_RESULTS_FROM_TO" xml:space="preserve">
    <value>Get splitted results from index {0} to index {1}.</value>
  </data>
  <data name="DBMANAGER_TOTAL_REQUEST_AMOUNT" xml:space="preserve">
    <value>Total request amount: {0}.</value>
  </data>
  <data name="DBMANAGER_UNPROXY_ORGUNITS" xml:space="preserve">
    <value>OrgUnitConfig after call to unproxy: {0}</value>
  </data>
  <data name="DBMANAGER_UPDATE_ENTITY" xml:space="preserve">
    <value>Instance of type {0} updated successfully in database.</value>
  </data>
  <data name="DBSESSION_NHIBERNATE_CONFIG_READY" xml:space="preserve">
    <value>NHibernate successfully configured.</value>
  </data>
  <data name="DBSESSION_OPEN_SESSION" xml:space="preserve">
    <value>Open new session.</value>
  </data>
  <data name="EMAIL_NOTIFIER_ADD_MAILBODY" xml:space="preserve">
    <value>Add mail body: [{0}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_ADD_RECIPIENT" xml:space="preserve">
    <value>Add mail recipient {0}.</value>
  </data>
  <data name="EMAIL_NOTIFIER_BUID_MAIL" xml:space="preserve">
    <value>Build mail from [{0}] with subject: [{1}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_CRAWL_FAILED" xml:space="preserve">
    <value>Crawl failed.</value>
  </data>
  <data name="EMAIL_NOTIFIER_CRAWL_FAILED_BODY" xml:space="preserve">
    <value>The Crawl failed:\n\n{0}</value>
  </data>
  <data name="EMAIL_NOTIFIER_CRAWL_FAILED_SUBJECT" xml:space="preserve">
    <value>Crawl failed.</value>
  </data>
  <data name="EMAIL_NOTIFIER_DESERIALIZE_ADDESSSES" xml:space="preserve">
    <value>Deserializing of addresses [{0}] finished.</value>
  </data>
  <data name="EMAIL_NOTIFIER_GET_ORG_UNIT" xml:space="preserve">
    <value>Got org unit [{0}] for entity [{1}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_ISSUE_FOUND_SUBJECT" xml:space="preserve">
    <value>New issues for System {0} found.</value>
  </data>
  <data name="EMAIL_NOTIFIER_NO_ADDRESSES" xml:space="preserve">
    <value>No email addresses found.</value>
  </data>
  <data name="EMAIL_NOTIFIER_NO_SETTINGS" xml:space="preserve">
    <value>There are no email settings. Please configure your email provider first.</value>
  </data>
  <data name="EMAIL_NOTIFIER_SEARCH_FINISHED" xml:space="preserve">
    <value>Search finished for OrgUnit: [{0}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_SEND_MAIL" xml:space="preserve">
    <value>Send mail from {0} with subject {1} to {2}</value>
  </data>
  <data name="EMAIL_NOTIFIER_SEND_MAIL_TO_ENTITY_OWNER" xml:space="preserve">
    <value>Send mail: entity: [{0}], subject: [{1}], body: [{2}]</value>
  </data>
  <data name="ERROR_TIME_INIT" xml:space="preserve">
    <value>Error during time initialisation, error was:\n{0}</value>
  </data>
  <data name="LOG_COMMON_ERROR" xml:space="preserve">
    <value>Common error: {0}</value>
  </data>
  <data name="LOG_COUNTDOWN_INITIALIZE" xml:space="preserve">
    <value>Initialize a new instance of Countdown</value>
  </data>
  <data name="LOG_COUNTDOWN_SET_REPEAT_TIME" xml:space="preserve">
    <value>Set new repeat time.</value>
  </data>
  <data name="LOG_COUNTDOWN_START_COUNTDOWN" xml:space="preserve">
    <value>Start new countdown.</value>
  </data>
  <data name="LOG_COUNTDOWN_THREAD_ENDS" xml:space="preserve">
    <value>Thread left while loop.</value>
  </data>
  <data name="LOG_COUNTDOWN_THREAD_IS_RUNNING" xml:space="preserve">
    <value>Thread is running.</value>
  </data>
  <data name="LOG_DISPATCHER_ZERO" xml:space="preserve">
    <value>Job dispatcher timer reached zero.</value>
  </data>
  <data name="LOG_FETCH_JOBS_FROM_DB" xml:space="preserve">
    <value>Fetch jobs from database.</value>
  </data>
  <data name="LOG_FILE_CREATION_SUCCESS" xml:space="preserve">
    <value>File {0} at {1} successfully created.</value>
  </data>
  <data name="LOG_FILE_READING_ERROR" xml:space="preserve">
    <value>Error while reading from file {0}, error was: {1}</value>
  </data>
  <data name="LOG_FILE_WRITING_ERROR" xml:space="preserve">
    <value>Error while writing to file {0} on host {1}, error was: {2}.</value>
  </data>
  <data name="LOG_GOT_SCHEDULER_LIST_FROM_DB" xml:space="preserve">
    <value>Got SchdulerTimer from database:[{0}]</value>
  </data>
  <data name="LOG_INDEX_OUT_OF_RANGE" xml:space="preserve">
    <value>The index was out of range: {0}.</value>
  </data>
  <data name="LOG_INSTANCIATE_NEW_SCHEDULER" xml:space="preserve">
    <value>Instanciate a new scheduler.</value>
  </data>
  <data name="LOG_PREFIX_FILE_NOT_FOUND" xml:space="preserve">
    <value>Prefix file does not exist, create it.</value>
  </data>
  <data name="LOG_RESTART_DISPATCHER" xml:space="preserve">
    <value>Job dispatcher timer restarted.</value>
  </data>
  <data name="LOG_SCHEDULER_ADD" xml:space="preserve">
    <value>Add SchedulerTimer [{0}]</value>
  </data>
  <data name="LOG_SCHEDULER_ALREADY_EXIST" xml:space="preserve">
    <value>The SchedulerTimer already exists.</value>
  </data>
  <data name="LOG_SCHEDULER_REMOVE" xml:space="preserve">
    <value>Remove OrgUnitConfig [{0}].</value>
  </data>
  <data name="LOG_SSH_ERROR" xml:space="preserve">
    <value>SSH communication error: {0}</value>
  </data>
  <data name="LOG_START_SERVICE" xml:space="preserve">
    <value>Start service {0} with ID: {1}.</value>
  </data>
  <data name="LOG_STOP_SERVICE" xml:space="preserve">
    <value>Stop service {0} with ID: {1}.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_ERROR" xml:space="preserve">
    <value>An error occured in countdown [{0}], message was: [{1}].</value>
  </data>
  <data name="NUTCHMANAGER_NO_MANAGER_FOUND" xml:space="preserve">
    <value>NutchManager does not exist, create one</value>
  </data>
  <data name="NUTCH_CONTROLLER_ADD_URL" xml:space="preserve">
    <value>Add URL {0} to client {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CHECK_CLIENT_USAGE" xml:space="preserve">
    <value>Check client usability.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENTS_SPLIT" xml:space="preserve">
    <value>Got clients: [{0}].</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_ADD_PREFIX" xml:space="preserve">
    <value>Add known prefix {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_AUTHENTICATION_EXCEPTION" xml:space="preserve">
    <value>Authentication failed for host {0}: {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_COMMAND_EXECUTED" xml:space="preserve">
    <value>Executed command {0} on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CONNECT" xml:space="preserve">
    <value>Connect to host {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CONNECTION_EXEPTION" xml:space="preserve">
    <value>Connection failed for host {0}: {1}</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CRAWLER_LOG" xml:space="preserve">
    <value>Crawler log for host {0}:{1}</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CRAWL_END" xml:space="preserve">
    <value>Crawl on host {0} finished.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CRAWL_FINISHED" xml:space="preserve">
    <value>Crawling on host {0} finished.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CRAWL_PROCESS_CREATED" xml:space="preserve">
    <value>Crawl process {0} was created on host {1}. </value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CREATE_DIRECTORY" xml:space="preserve">
    <value>Try to create new directory {0} on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CREATE_NEW" xml:space="preserve">
    <value>Create new NutchControllerClient: {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_DIRECTORY_CREATION_ERROR" xml:space="preserve">
    <value>The directory {0} could not be created on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_DIRECTORY_CREATION_SUCCESS" xml:space="preserve">
    <value>The directory {0} was successfully created on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_DISCONNECT" xml:space="preserve">
    <value>Disconnect from host {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_FILE_EXISTS" xml:space="preserve">
    <value>File {0} of type {1} exists on host {2},</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_FILE_NOT_EXISTS" xml:space="preserve">
    <value>File {0} of type {1} does not exists on host {2},</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_FILE_READING_SUCCESS" xml:space="preserve">
    <value>File {0} successfully read on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_GOT_FILE_CONTENT" xml:space="preserve">
    <value>Got file content on host {0}: {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_HADOOP_LOG" xml:space="preserve">
    <value>An excerpt of hadoop.log of host {0} shows: {1}</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_HOST_IS_USABLE" xml:space="preserve">
    <value>Host {0} can crawl {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_NOT_CONNECTED" xml:space="preserve">
    <value>Host {0} is null or not connected.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_NOT_USABLE" xml:space="preserve">
    <value>Client {0} is not usable.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_NUTCH_COMMAND_ERROR" xml:space="preserve">
    <value>The remotehost {0} gots an error while executing nutch: {1}</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_NUTCH_INSTALLED" xml:space="preserve">
    <value>Nutch is installed on host {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_NUTCH_NOT_INSTALLED" xml:space="preserve">
    <value>Nutch is not installed on host {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_PREFIX_ADDED" xml:space="preserve">
    <value>New prefix {0} added on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_PREFIX_EXISTS" xml:space="preserve">
    <value>Prefix {0} already exists on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_SSH_TIMEOUT_EXCEPTION" xml:space="preserve">
    <value>Connection timed out for host {0}: {1}</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_START_CRAWL" xml:space="preserve">
    <value>Start crawl on host {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_USER_PATH_IS" xml:space="preserve">
    <value>User path on host {0} is {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_WRITE_FILE" xml:space="preserve">
    <value>Write content {0} to file {1} in mode {2} on host {3}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_WRITING_SUCCESS" xml:space="preserve">
    <value>Content {0} successfully written on host {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CRAWLS_FINISHED" xml:space="preserve">
    <value>All crawls finished.</value>
  </data>
  <data name="NUTCH_CONTROLLER_CRAWL_FINISHED" xml:space="preserve">
    <value>Crawl finished, crawls left: {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_DISCONNECT" xml:space="preserve">
    <value>Try to disconnect host {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_DO_NOT_CRAWL_ON_HOST" xml:space="preserve">
    <value>Host {0} will not be used for crawling. See other log messages for further details.</value>
  </data>
  <data name="NUTCH_CONTROLLER_DO_NOT_CRAWL_ON_HOST_NO_URLS" xml:space="preserve">
    <value>Host {0} will not be used for crawling because it has no urls: [{1}].</value>
  </data>
  <data name="NUTCH_CONTROLLER_INITIALIZE_CLIENT" xml:space="preserve">
    <value>Initialize clients.</value>
  </data>
  <data name="NUTCH_CONTROLLER_INITIALIZE_CLIENT_FINISHED" xml:space="preserve">
    <value>Clients initialized.</value>
  </data>
  <data name="NUTCH_CONTROLLER_INIT_NEXT_CRAWL" xml:space="preserve">
    <value>Initialize next crawl.</value>
  </data>
  <data name="NUTCH_CONTROLLER_IS_ALIVE" xml:space="preserve">
    <value>Nutch controller is still alive.</value>
  </data>
  <data name="NUTCH_CONTROLLER_NEW_CLIENT_INITIALIZED" xml:space="preserve">
    <value>New client initialized: [{0}].</value>
  </data>
  <data name="NUTCH_CONTROLLER_NO_INITIALIZING_NO_SETTINGS" xml:space="preserve">
    <value>Can not initialize clients because there are no settings. Please configure nutch first.</value>
  </data>
  <data name="NUTCH_CONTROLLER_NO_SETTINGS" xml:space="preserve">
    <value>Please configure the nutch controller first, skip crawling.</value>
  </data>
  <data name="NUTCH_CONTROLLER_NO_USABLE_CLIENT" xml:space="preserve">
    <value>Can not connect to any of the specified hosts: {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_RESET_CLIENTS" xml:space="preserve">
    <value>Reset URLs for client {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_SET_CRAWL_PROCESS" xml:space="preserve">
    <value>Set next crawl process for client {0}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_SET_PENDING_CRAWL" xml:space="preserve">
    <value>Set pending job on host {0} for urls: {1}</value>
  </data>
  <data name="NUTCH_CONTROLLER_SET_RUNNING_CRAWLS" xml:space="preserve">
    <value>New crawl jobs received, set as running crawls.</value>
  </data>
  <data name="NUTCH_CONTROLLER_SOCKET_EXCEPTION" xml:space="preserve">
    <value>Can not connect to host {0}: {1}.</value>
  </data>
  <data name="NUTCH_CONTROLLER_START_CRAWL" xml:space="preserve">
    <value>Start new crawl.</value>
  </data>
  <data name="NUTCH_CONTROLLER_UPDATE_SETTINGS" xml:space="preserve">
    <value>Update settings [{0}] =&gt; [{1}].</value>
  </data>
  <data name="NUTCH_CONTROLLER_UPDATE_URLS" xml:space="preserve">
    <value>Update URLs: {0}.</value>
  </data>
  <data name="RESULT_TO_STRING" xml:space="preserve">
    <value>Issue {0} found on website: {1}, content: {2} at {3}</value>
  </data>
  <data name="SCHEDULER_CANT_SET_JOB" xml:space="preserve">
    <value>Can not set job for OrgUnitConfig [{0}].</value>
  </data>
  <data name="SCHEDULER_CRAWL_FAILED" xml:space="preserve">
    <value>The crawl failed: OrgUnit [{0}].</value>
  </data>
  <data name="SCHEDULER_CRAWL_RESTART" xml:space="preserve">
    <value>Scheduler starts new timer for crawl job.</value>
  </data>
  <data name="SCHEDULER_CRAWL_SUCCEEDED" xml:space="preserve">
    <value>The crawl finished without errors.</value>
  </data>
  <data name="SCHEDULER_CREATE_NEW_JOB" xml:space="preserve">
    <value>Create new job for OrgUnitConfig [{0}].</value>
  </data>
  <data name="SCHEDULER_ON_TICK" xml:space="preserve">
    <value>Countdown [{0}] has remaintime: [{1}].</value>
  </data>
  <data name="SCHEDULER_SKIP_NOT_ACTIVE_JOB" xml:space="preserve">
    <value>Skip not active job {0}.</value>
  </data>
  <data name="SCHEDULER_UPDATE_JOB" xml:space="preserve">
    <value>Update job {0}.</value>
  </data>
  <data name="SEARCH_RECALL" xml:space="preserve">
    <value>Recall for OrgUnit [{0}]</value>
  </data>
  <data name="SEARCH_RECALL_START_SERVICE" xml:space="preserve">
    <value>New search started, running searches: [{0}]</value>
  </data>
  <data name="SEARCH_RECALL_THREAD_STATE" xml:space="preserve">
    <value>Current thread state running: {0}, running searches: {1}, timeout: {2}</value>
  </data>
  <data name="SEARCH_RECALL_THREAD_STATE_END" xml:space="preserve">
    <value>Thread state at end running: {0}, running searches: {1}, timeout: {2}</value>
  </data>
  <data name="SERVICE_IS_ALREADY_UP" xml:space="preserve">
    <value>Service {0} is already up</value>
  </data>
  <data name="SERVICE_IS_NOT_RUNNING" xml:space="preserve">
    <value>Service {0} is not running.</value>
  </data>
  <data name="SOLR_CLIENT_CLOSE_CONNECTION" xml:space="preserve">
    <value>Close Connection</value>
  </data>
  <data name="SOLR_CLIENT_CONNECTION_ESTABLISHED" xml:space="preserve">
    <value>Connection Established to host: [{0}]</value>
  </data>
  <data name="SOLR_CLIENT_MESSAGE_SENT" xml:space="preserve">
    <value>Message was send: [{0}]</value>
  </data>
  <data name="SOLR_CLIENT_QUERY_BUILT" xml:space="preserve">
    <value>Query to Solr successfully build.</value>
  </data>
  <data name="SOLR_CLIENT_RESULT_RECEIVED" xml:space="preserve">
    <value>Message from host: [{0}] received with content: [{1}]</value>
  </data>
  <data name="SOLR_CLIENT_SOCKET_CLOSED" xml:space="preserve">
    <value>Socket to host: [{0}] closed.</value>
  </data>
  <data name="SOLR_CLIENT_TRY_GET_RESPONSE" xml:space="preserve">
    <value>Waiting for response from Solr.</value>
  </data>
  <data name="SOLR_CLIENT_UNABLE_TO_CONNECT" xml:space="preserve">
    <value>Unable to Connect to host: [{0}]</value>
  </data>
  <data name="SOLR_SEARCH_COMPONENT_FINISHED" xml:space="preserve">
    <value>Search for component {0} finished.</value>
  </data>
  <data name="SOLR_SEARCH_COMPONENT_STARTED" xml:space="preserve">
    <value>Search for component {0} started.</value>
  </data>
  <data name="SOLR_SEARCH_CONTROLLER_NO_COMPONENTS" xml:space="preserve">
    <value>There are no componets for OrgUnit {0}.</value>
  </data>
  <data name="SOLR_SEARCH_CONTROLLER_NO_NEW_RESULTS" xml:space="preserve">
    <value>No new results found for {0}.</value>
  </data>
  <data name="SOLR_SEARCH_CONTROLLER_NO_ORGUNIT" xml:space="preserve">
    <value>There is no OrgUnit for ID {0}.</value>
  </data>
  <data name="SOLR_SEARCH_CONTROLLER_NO_SETTINGS" xml:space="preserve">
    <value>No settings found, skip search. Please configure Solr first.</value>
  </data>
  <data name="SOLR_SEARCH_CONTROLLER_RESULT_ERROR" xml:space="preserve">
    <value>Error while computing the search results, error was: {0}.</value>
  </data>
  <data name="SOLR_SEARCH_KNOWN_RESULT" xml:space="preserve">
    <value>Result already in database: [{0}].</value>
  </data>
  <data name="SOLR_SEARCH_NEW_RESULT" xml:space="preserve">
    <value>Add new result</value>
  </data>
  <data name="SOLR_SEARCH_NO_RESULTS" xml:space="preserve">
    <value>No results for {0} found.</value>
  </data>
  <data name="SOLR_SEARCH_ORGUNIT_FINISHED" xml:space="preserve">
    <value>Search for OrgUnit {0} finished.</value>
  </data>
  <data name="TIME_TO_STRING" xml:space="preserve">
    <value>Remaining time: [ID: {0} - {1}D : {2}H : {3}m : {4}s]</value>
  </data>
  <data name="WCF_COMMUNICATION_ERROR" xml:space="preserve">
    <value>Communication error: {0}</value>
  </data>
  <data name="WCF_CONTROLLER_CLIENT_CREATE_BINDING" xml:space="preserve">
    <value>Create binding for proxy.</value>
  </data>
  <data name="WCF_CONTROLLER_CLIENT_CREATE_ENDPOINT" xml:space="preserve">
    <value>Create endpoint for proxy.</value>
  </data>
  <data name="WCF_CONTROLLER_CLIENT_TRY_GET_PROXY" xml:space="preserve">
    <value>Try get new client proxy.</value>
  </data>
  <data name="WCF_CONTROLLER_WCF_HOST_CLOSED" xml:space="preserve">
    <value>WCF service host {0} closed.</value>
  </data>
  <data name="WCF_CONTROLLER_WCF_HOST_OPENED" xml:space="preserve">
    <value>WCF service host {0} opened.</value>
  </data>
</root>