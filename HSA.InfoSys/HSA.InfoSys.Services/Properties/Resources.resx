<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CRAWL_CONTROLLER_SHUTDOWN" xml:space="preserve">
    <value>Shutdown Services.</value>
  </data>
  <data name="CRAWL_CONTROLLER_START" xml:space="preserve">
    <value>Start crawl controller</value>
  </data>
  <data name="DBMANAGER_ADD_ENTITY" xml:space="preserve">
    <value>Instance saved successfully in database.</value>
  </data>
  <data name="DBMANAGER_CREATE_COMPONENT" xml:space="preserve">
    <value>New component [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_ORGUNIT" xml:space="preserve">
    <value>New org unit [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_ORGUNITCONFIG" xml:space="preserve">
    <value>New org unit configuration [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_RESULT" xml:space="preserve">
    <value>New result [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_SCHEDULER" xml:space="preserve">
    <value>New scheduler [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_SOURCE" xml:space="preserve">
    <value>New source [{0}] created.</value>
  </data>
  <data name="DBMANAGER_CREATE_SYSTEMSERVICE" xml:space="preserve">
    <value>New systemservice [{0}] created.</value>
  </data>
  <data name="DBMANAGER_DELETE_ENTITY" xml:space="preserve">
    <value>Deleted entity [{0}]</value>
  </data>
  <data name="DBMANAGER_EAGER_LOAD_THIS_ENTITIES" xml:space="preserve">
    <value>Load this entities [{0}] eager from database.</value>
  </data>
  <data name="DBMANAGER_GET_COMPONENT_BY_ORGUNIT_ID" xml:space="preserve">
    <value>Got components: [{0}] by GUID: [{1}].</value>
  </data>
  <data name="DBMANAGER_GET_ENTITY" xml:space="preserve">
    <value>Got entity of type [{0}] with values [{1}] by GUID [{2}]</value>
  </data>
  <data name="DBMANAGER_GET_ORGUNIT_BY_USERID" xml:space="preserve">
    <value>Got org unit [{0}] by id [{1}]</value>
  </data>
  <data name="DBMANAGER_GET_RESULTS_BY_COMPONENT_ID" xml:space="preserve">
    <value>Got results: [{0}] by GUID: [{1}].</value>
  </data>
  <data name="DBMANAGER_NO_MANAGER_FOUND" xml:space="preserve">
    <value>DBManager does not exist, create one.</value>
  </data>
  <data name="DBMANAGER_UPDATE_ENTITY" xml:space="preserve">
    <value>Instance updated successfully in database.</value>
  </data>
  <data name="DBSESSION_NHIBERNATE_CONFIG_READY" xml:space="preserve">
    <value>NHibernate successfully configured.</value>
  </data>
  <data name="DBSESSION_OPEN_SESSION" xml:space="preserve">
    <value>Open new session.</value>
  </data>
  <data name="EMAIL_NOTIFIER_ADD_MAILBODY" xml:space="preserve">
    <value>Add mail body: [{0}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_ADD_RECIPIENT" xml:space="preserve">
    <value>Add mail recipient {0} for OrgUnit {1}.</value>
  </data>
  <data name="EMAIL_NOTIFIER_BUID_MAIL" xml:space="preserve">
    <value>Build mail from [{0}] with subject: [{1}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_CRAWL_FAILED" xml:space="preserve">
    <value>Crawl failed for OrgUnit: [{0}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_CRAWL_FAILED_BODY" xml:space="preserve">
    <value>The crawl for {0} failed.</value>
  </data>
  <data name="EMAIL_NOTIFIER_CRAWL_FAILED_SUBJECT" xml:space="preserve">
    <value>Crawl failed.</value>
  </data>
  <data name="EMAIL_NOTIFIER_DESERIALIZE_ADDESSSES" xml:space="preserve">
    <value>Deserializing of addresses [{0}] finished.</value>
  </data>
  <data name="EMAIL_NOTIFIER_GET_ORG_UNIT" xml:space="preserve">
    <value>Got org unit [{0}] for entity [{1}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_ISSUE_FOUND_SUBJECT" xml:space="preserve">
    <value>New issues for System {0} found.</value>
  </data>
  <data name="EMAIL_NOTIFIER_NO_ADDRESSES" xml:space="preserve">
    <value>No email addresses found.</value>
  </data>
  <data name="EMAIL_NOTIFIER_SEARCH_FINISHED" xml:space="preserve">
    <value>Search finished for OrgUnit: [{0}]</value>
  </data>
  <data name="EMAIL_NOTIFIER_SEND_MAIL" xml:space="preserve">
    <value>Send mail from {0} with subject {1} to {2}</value>
  </data>
  <data name="EMAIL_NOTIFIER_SEND_MAIL_TO_ENTITY_OWNER" xml:space="preserve">
    <value>Send mail: entity: [{0}], subject: [{1}], body: [{2}]</value>
  </data>
  <data name="ERROR_TIME_INIT" xml:space="preserve">
    <value>Error during time initialisation, error was:\n{0}</value>
  </data>
  <data name="LOG_COMMON_ERROR" xml:space="preserve">
    <value>Common error: {0}</value>
  </data>
  <data name="LOG_DIRECTORY_CREATION_ERROR" xml:space="preserve">
    <value>The directory {0} could not be created.</value>
  </data>
  <data name="LOG_DISPATCHER_ZERO" xml:space="preserve">
    <value>Job dispatcher timer reached zero.</value>
  </data>
  <data name="LOG_FETCH_JOBS_FROM_DB" xml:space="preserve">
    <value>Fetch jobs from database.</value>
  </data>
  <data name="LOG_FILE_CREATION_SUCCESS" xml:space="preserve">
    <value>File {0} at {1} successfully created.</value>
  </data>
  <data name="LOG_FILE_READING_ERROR" xml:space="preserve">
    <value>Error while reading from file {0}, error was: {1}</value>
  </data>
  <data name="LOG_FILE_READING_SUCCESS" xml:space="preserve">
    <value>File {0} successfully read.</value>
  </data>
  <data name="LOG_FILE_WRITING_ERROR" xml:space="preserve">
    <value>Error while writing to file {0}, error was: {1}.</value>
  </data>
  <data name="LOG_FILE_WRITING_SUCCESS" xml:space="preserve">
    <value>Url {0} successfully written.</value>
  </data>
  <data name="LOG_GOT_SCHEDULER_LIST_FROM_DB" xml:space="preserve">
    <value>Got SchdulerTimer from database:[{0}]</value>
  </data>
  <data name="LOG_INSTANCIATE_NEW_SCHEDULER" xml:space="preserve">
    <value>Instanciate a new scheduler.</value>
  </data>
  <data name="LOG_PREFIX_ADDED" xml:space="preserve">
    <value>New prefix {0} added.</value>
  </data>
  <data name="LOG_PREFIX_FILE_NOT_FOUND" xml:space="preserve">
    <value>Prefix file does not exist, create it.</value>
  </data>
  <data name="LOG_RESTART_DISPATCHER" xml:space="preserve">
    <value>Job dispatcher timer restarted.</value>
  </data>
  <data name="LOG_SCHEDULER_ADD" xml:space="preserve">
    <value>Add SchedulerTimer [{0}]</value>
  </data>
  <data name="LOG_SCHEDULER_ALREADY_EXIST" xml:space="preserve">
    <value>The SchedulerTimer already exists.</value>
  </data>
  <data name="LOG_SCHEDULER_REMOVE" xml:space="preserve">
    <value>Remove OrgUnitConfig [{0}].</value>
  </data>
  <data name="LOG_START_SERVICE" xml:space="preserve">
    <value>Start service {0}.</value>
  </data>
  <data name="LOG_STOP_SERVICE" xml:space="preserve">
    <value>Stop service {0}.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_ERROR" xml:space="preserve">
    <value>An error occured in countdown [{0}], message was: [{1}].</value>
  </data>
  <data name="NUTCHMANAGER_NO_MANAGER_FOUND" xml:space="preserve">
    <value>NutchManager does not exist, create one</value>
  </data>
  <data name="NUTCH_CONTROLLER_CLIENT_CRAWL_PROCESS_CREATED" xml:space="preserve">
    <value>Crawl process was created: {0}</value>
  </data>
  <data name="NUTCH_CONTROLLER_SET_PENDING_CRAWL" xml:space="preserve">
    <value>Set pending job for urls: {0}</value>
  </data>
  <data name="NUTCH_CONTROLLER_SET_RUNNING_CRAWLS" xml:space="preserve">
    <value>New crawl jobs received, set as running crawls.</value>
  </data>
  <data name="RESULT_TO_STRING" xml:space="preserve">
    <value>Issue {0} found on website: {1}, content: {2} at {3}</value>
  </data>
  <data name="SCHEDULER_CANT_SET_JOB" xml:space="preserve">
    <value>Can not set job for OrgUnitConfig [{0}].</value>
  </data>
  <data name="SCHEDULER_CRAWL_FAILED" xml:space="preserve">
    <value>The crawl failed: OrgUnit [{0}].</value>
  </data>
  <data name="SCHEDULER_CRAWL_RESTART" xml:space="preserve">
    <value>Scheduler starts new crawl job</value>
  </data>
  <data name="SCHEDULER_CRAWL_SUCCEEDED" xml:space="preserve">
    <value>The crawl finished without errors.</value>
  </data>
  <data name="SCHEDULER_CREATE_NEW_JOB" xml:space="preserve">
    <value>Create new job for OrgUnitConfig [{0}].</value>
  </data>
  <data name="SCHEDULER_ON_TICK" xml:space="preserve">
    <value>Countdown [{0}] has remaintime: [{1}].</value>
  </data>
  <data name="SEARCH_RECALL" xml:space="preserve">
    <value>Recall for OrgUnit [{0}]</value>
  </data>
  <data name="SEARCH_RECALL_START_SERVICE" xml:space="preserve">
    <value>New search started, running searches: [{0}]</value>
  </data>
  <data name="SEARCH_RECALL_THREAD_STATE" xml:space="preserve">
    <value>Current thread state running: {0}, running searches: {1}, timeout: {2}</value>
  </data>
  <data name="SEARCH_RECALL_THREAD_STATE_END" xml:space="preserve">
    <value>Thread state at end running: {0}, running searches: {1}, timeout: {2}</value>
  </data>
  <data name="SOLR_CLIENT_CLOSE_CONNECTION" xml:space="preserve">
    <value>Close Connection</value>
  </data>
  <data name="SOLR_CLIENT_CONNECTION_ESTABLISHED" xml:space="preserve">
    <value>Connection Established to host: [{0}]</value>
  </data>
  <data name="SOLR_CLIENT_MESSAGE_SENT" xml:space="preserve">
    <value>Message was send: [{0}]</value>
  </data>
  <data name="SOLR_CLIENT_REQUEST_RECEIVED" xml:space="preserve">
    <value>Received a request for a solr query: [{0}]</value>
  </data>
  <data name="SOLR_CLIENT_RESULT_RECEIVED" xml:space="preserve">
    <value>Message from host: [{0}] received with content: [{1}]</value>
  </data>
  <data name="SOLR_CLIENT_SOCKET_CLOSED" xml:space="preserve">
    <value>Socket to host: [{0}] closed.</value>
  </data>
  <data name="SOLR_CLIENT_TRY_GET_RESPONSE" xml:space="preserve">
    <value>Waiting for response from Solr.</value>
  </data>
  <data name="SOLR_CLIENT_UNABLE_TO_CONNECT" xml:space="preserve">
    <value>Unable to Connect to host: [{0}]</value>
  </data>
  <data name="SOLR_SEARCH_COMPONENT_FINISHED" xml:space="preserve">
    <value>Search for component {0} finished.</value>
  </data>
  <data name="SOLR_SEARCH_COMPONENT_STARTED" xml:space="preserve">
    <value>Search for component {0} started.</value>
  </data>
  <data name="SOLR_SEARCH_ORGUNIT_FINISHED" xml:space="preserve">
    <value>Search for OrgUnit {0} finished.</value>
  </data>
  <data name="SOLR_SEARCH_RESULT" xml:space="preserve">
    <value>Response for query [{0}] is: [{1}]</value>
  </data>
  <data name="WCF_COMMUNICATION_ERROR" xml:space="preserve">
    <value>Communication error: {0}</value>
  </data>
  <data name="WCF_CONTROLLER_WCF_HOST_CLOSED" xml:space="preserve">
    <value>WCF service host {0} closed.</value>
  </data>
  <data name="WCF_CONTROLLER_WCF_HOST_OPENED" xml:space="preserve">
    <value>WCF service host {0} opened.</value>
  </data>
</root>