.TH "NHibernate.Test.UtilityTest" 3 "Fri Jul 5 2013" "Version 1.0" "HSA.InfoSys" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NHibernate.Test.UtilityTest \- 
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "package \fBEnumerableExtensionsTests\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBArrayHelperTests\fP"
.br
.ti -1c
.RI "class \fBAssemblyQualifiedTypeNameFixture\fP"
.br
.ti -1c
.RI "class \fBBasicFormatterFixture\fP"
.br
.ti -1c
.RI "class \fBTestingClass\fP"
.br
.ti -1c
.RI "class \fBExpressionsHelperFixture\fP"
.br
.ti -1c
.RI "class \fBIdentityMapFixture\fP"
.br
.RI "\fI\fBTest\fP for the IdentityMap\&. \fP"
.ti -1c
.RI "class \fBIdentityMapSequencedFixture\fP"
.br
.RI "\fITests a Sequenced Identity Map\&. \fP"
.ti -1c
.RI "class \fBIdentitySetFixture\fP"
.br
.RI "\fI\fBTest\fP for the IdentityMap\&. \fP"
.ti -1c
.RI "class \fBJoinedEnumerableFixture\fP"
.br
.RI "\fI\fBTest\fP cases for the JoinedEnumerable class\&. \fP"
.ti -1c
.RI "class \fBEnumerableTester\fP"
.br
.RI "\fISimple class that wraps an array list for testing purposes\&. \fP"
.ti -1c
.RI "class \fBJoinedEnumerableGenericFixture\fP"
.br
.ti -1c
.RI "class \fBEnumerableTester< T >\fP"
.br
.ti -1c
.RI "class \fBLinkedHashMapFixture\fP"
.br
.ti -1c
.RI "class \fBPlayer\fP"
.br
.ti -1c
.RI "class \fBLRUMapFixture\fP"
.br
.ti -1c
.RI "class \fBMutableHashCode\fP"
.br
.RI "\fIProvides an object whose HashCode is based on a Mutable field\&. Not a good practice but perfect for testing IdentityMap because it simulates an object being loaded with its default constructor (no params) and then having the fields initialized\&. If the class overrides GetHashCode() then it will be inconsistent between the construction and field population by \fBNHibernate\fP\&. \fP"
.ti -1c
.RI "class \fBNoHashCode\fP"
.br
.RI "\fIThe IdentityMap should not ever call the GetHashCode() because that will have side effects on Collections/Entities\&. \fP"
.ti -1c
.RI "class \fBPropertiesHelperTest\fP"
.br
.ti -1c
.RI "class \fBReflectHelperFixture\fP"
.br
.RI "\fISummary description for \fBReflectHelperFixture\fP\&. \fP"
.ti -1c
.RI "interface \fBISomething\fP"
.br
.ti -1c
.RI "class \fBARhf\fP"
.br
.ti -1c
.RI "class \fBBRhf\fP"
.br
.ti -1c
.RI "interface \fBIMyBaseInterface\fP"
.br
.ti -1c
.RI "interface \fBIMyInterface\fP"
.br
.ti -1c
.RI "class \fBMyBaseImplementation\fP"
.br
.ti -1c
.RI "class \fBMyDerivedImplementation\fP"
.br
.ti -1c
.RI "class \fBMyImplementation\fP"
.br
.ti -1c
.RI "class \fBReflectHelperGetProperty\fP"
.br
.ti -1c
.RI "class \fBReflectionHelperIsMethodOfTests\fP"
.br
.ti -1c
.RI "class \fBReflectionHelperTest\fP"
.br
.ti -1c
.RI "class \fBSafetyEnumerableFixture\fP"
.br
.RI "\fI\fBTest\fP cases for the SafetyEnumerable{T} class\&. \fP"
.ti -1c
.RI "interface \fBIAType\fP"
.br
.ti -1c
.RI "class \fBAClass\fP"
.br
.ti -1c
.RI "class \fBBClass\fP"
.br
.ti -1c
.RI "class \fBSequencedHashMapFixture\fP"
.br
.RI "\fISummary description for \fBSequencedHashMapFixture\fP\&. \fP"
.ti -1c
.RI "class \fBSingletonEnumerableFixture\fP"
.br
.ti -1c
.RI "class \fBSoftLimitMRUCacheFixture\fP"
.br
.ti -1c
.RI "class \fBStringHelperFixture\fP"
.br
.RI "\fISummary description for \fBStringHelperFixture\fP\&. \fP"
.ti -1c
.RI "class \fBThreadSafeDictionaryFixture\fP"
.br
.ti -1c
.RI "class \fBTypeNameParserFixture\fP"
.br
.ti -1c
.RI "class \fBWeakHashtableFixture\fP"
.br
.in -1c
.SH "Author"
.PP 
Generated automatically by Doxygen for HSA\&.InfoSys from the source code\&.
