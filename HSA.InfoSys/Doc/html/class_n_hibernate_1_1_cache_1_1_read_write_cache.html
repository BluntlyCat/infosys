<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>HSA.InfoSys: NHibernate.Cache.ReadWriteCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hsasec.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">HSA.InfoSys
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Crawls webpages for security issues, collect this information and views the results for specified components.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_n_hibernate_1_1_cache_1_1_read_write_cache.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_n_hibernate_1_1_cache_1_1_read_write_cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NHibernate.Cache.ReadWriteCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Caches data that is sometimes updated while maintaining the semantics of "read committed" isolation level. If the database is set to "repeatable
read", this concurrency strategy <em>almost</em> maintains the semantics. Repeatable read isolation is compromised in the case of concurrent writes. This is an "asynchronous" concurrency strategy.  
 <a href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for NHibernate.Cache.ReadWriteCache:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_n_hibernate_1_1_cache_1_1_read_write_cache.png" usemap="#NHibernate.Cache.ReadWriteCache_map" alt=""/>
  <map id="NHibernate.Cache.ReadWriteCache_map" name="NHibernate.Cache.ReadWriteCache_map">
<area href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html" title="Implementors manage transactional access to cached data. " alt="NHibernate.Cache.ICacheConcurrencyStrategy" shape="rect" coords="0,0,283,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_read_write_cache_1_1_i_lockable.html">ILockable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af32fddde4d4ea7bfa60cdb75543b60a3"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#af32fddde4d4ea7bfa60cdb75543b60a3">Get</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, long txTimestamp)</td></tr>
<tr class="memdesc:af32fddde4d4ea7bfa60cdb75543b60a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not return an item whose timestamp is later than the current transaction timestamp. (Otherwise we might compromise repeatable read unnecessarily.) Do not return an item which is soft-locked. Always go straight to the database instead.  <a href="#af32fddde4d4ea7bfa60cdb75543b60a3">More...</a><br/></td></tr>
<tr class="separator:af32fddde4d4ea7bfa60cdb75543b60a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33807ee0d8fde2542c5ccd4045a26bd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a33807ee0d8fde2542c5ccd4045a26bd3">Lock</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object version)</td></tr>
<tr class="memdesc:a33807ee0d8fde2542c5ccd4045a26bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop any other transactions reading or writing this item to/from the cache. Send them straight to the database instead. (The lock does time out eventually.) This implementation tracks concurrent locks by transactions which simultaneously attempt to write to an item.  <a href="#a33807ee0d8fde2542c5ccd4045a26bd3">More...</a><br/></td></tr>
<tr class="separator:a33807ee0d8fde2542c5ccd4045a26bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9dc40ad88b964bf7852c332485e301"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a7d9dc40ad88b964bf7852c332485e301">Put</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object value, long txTimestamp, object version, IComparer versionComparator, bool minimalPut)</td></tr>
<tr class="memdesc:a7d9dc40ad88b964bf7852c332485e301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not add an item to the cache unless the current transaction timestamp is later than the timestamp at which the item was invalidated. (Otherwise, a stale item might be re-added if the database is operating in repeatable read isolation mode.)  <a href="#a7d9dc40ad88b964bf7852c332485e301">More...</a><br/></td></tr>
<tr class="separator:a7d9dc40ad88b964bf7852c332485e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed324cd02a84662169ecfafed094dd8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed324cd02a84662169ecfafed094dd8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Release</b> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, <a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a> clientLock)</td></tr>
<tr class="separator:aed324cd02a84662169ecfafed094dd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299dd329b28de7a398cf8dbc8623ecef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a299dd329b28de7a398cf8dbc8623ecef">Clear</a> ()</td></tr>
<tr class="memdesc:a299dd329b28de7a398cf8dbc8623ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict all items from the cache immediately.  <a href="#a299dd329b28de7a398cf8dbc8623ecef">More...</a><br/></td></tr>
<tr class="separator:a299dd329b28de7a398cf8dbc8623ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade68002dda6052479e2faf51f1158bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#ade68002dda6052479e2faf51f1158bda">Remove</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key)</td></tr>
<tr class="memdesc:ade68002dda6052479e2faf51f1158bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict an item from the cache immediately (without regard for transaction isolation).  <a href="#ade68002dda6052479e2faf51f1158bda">More...</a><br/></td></tr>
<tr class="separator:ade68002dda6052479e2faf51f1158bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876f7ca2dd7826005ccaf79a8689da36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a876f7ca2dd7826005ccaf79a8689da36">Destroy</a> ()</td></tr>
<tr class="memdesc:a876f7ca2dd7826005ccaf79a8689da36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up all resources.  <a href="#a876f7ca2dd7826005ccaf79a8689da36">More...</a><br/></td></tr>
<tr class="separator:a876f7ca2dd7826005ccaf79a8689da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b61ead673cf1607b4d9df807d71357d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a3b61ead673cf1607b4d9df807d71357d">AfterUpdate</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object value, object version, <a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a> clientLock)</td></tr>
<tr class="memdesc:a3b61ead673cf1607b4d9df807d71357d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-cache the updated state, if and only if there there are no other concurrent soft locks. Release our lock.  <a href="#a3b61ead673cf1607b4d9df807d71357d">More...</a><br/></td></tr>
<tr class="separator:a3b61ead673cf1607b4d9df807d71357d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74d4e3832dcad4517f42f209253b931"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#ab74d4e3832dcad4517f42f209253b931">AfterInsert</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object value, object version)</td></tr>
<tr class="memdesc:ab74d4e3832dcad4517f42f209253b931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after an item has been inserted (after the transaction completes), instead of calling release().  <a href="#ab74d4e3832dcad4517f42f209253b931">More...</a><br/></td></tr>
<tr class="separator:ab74d4e3832dcad4517f42f209253b931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077c21e42cdcb719cd4c96625ecb79f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a077c21e42cdcb719cd4c96625ecb79f0">Evict</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key)</td></tr>
<tr class="memdesc:a077c21e42cdcb719cd4c96625ecb79f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after an item has become stale (before the transaction completes).  <a href="#a077c21e42cdcb719cd4c96625ecb79f0">More...</a><br/></td></tr>
<tr class="separator:a077c21e42cdcb719cd4c96625ecb79f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a92fdf57a1d9ce56c1b5f3288b014e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a4a92fdf57a1d9ce56c1b5f3288b014e8">Insert</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object value, object currentVersion)</td></tr>
<tr class="memdesc:a4a92fdf57a1d9ce56c1b5f3288b014e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after an item has been inserted (before the transaction completes), instead of calling <a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a077c21e42cdcb719cd4c96625ecb79f0" title="Called after an item has become stale (before the transaction completes). ">Evict()</a>.  <a href="#a4a92fdf57a1d9ce56c1b5f3288b014e8">More...</a><br/></td></tr>
<tr class="separator:a4a92fdf57a1d9ce56c1b5f3288b014e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7928ddf3c80e5e7b5ec03f209fc32376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a7928ddf3c80e5e7b5ec03f209fc32376">Update</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object value, object currentVersion, object previousVersion)</td></tr>
<tr class="memdesc:a7928ddf3c80e5e7b5ec03f209fc32376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after an item has been updated (before the transaction completes), instead of calling <a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a077c21e42cdcb719cd4c96625ecb79f0" title="Called after an item has become stale (before the transaction completes). ">Evict()</a>.  <a href="#a7928ddf3c80e5e7b5ec03f209fc32376">More...</a><br/></td></tr>
<tr class="separator:a7928ddf3c80e5e7b5ec03f209fc32376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html">NHibernate.Cache.ICacheConcurrencyStrategy</a></td></tr>
<tr class="memitem:a7dc182c529fffc911e12fb8024bc32c3 inherit pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a7dc182c529fffc911e12fb8024bc32c3">Release</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, <a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a> @lock)</td></tr>
<tr class="memdesc:a7dc182c529fffc911e12fb8024bc32c3 inherit pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when we have finished the attempted update/delete (which may or may not have been successful), after transaction completion.  <a href="#a7dc182c529fffc911e12fb8024bc32c3">More...</a><br/></td></tr>
<tr class="separator:a7dc182c529fffc911e12fb8024bc32c3 inherit pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b72bdcaad635d8f45870f06e1e078ca inherit pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a6b72bdcaad635d8f45870f06e1e078ca">AfterUpdate</a> (<a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a> key, object value, object version, <a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a> @lock)</td></tr>
<tr class="memdesc:a6b72bdcaad635d8f45870f06e1e078ca inherit pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after an item has been updated (after the transaction completes), instead of calling <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a7dc182c529fffc911e12fb8024bc32c3" title="Called when we have finished the attempted update/delete (which may or may not have been successful)...">Release()</a>.  <a href="#a6b72bdcaad635d8f45870f06e1e078ca">More...</a><br/></td></tr>
<tr class="separator:a6b72bdcaad635d8f45870f06e1e078ca inherit pub_methods_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a736a624c011e954c737723746fb86e62"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a736a624c011e954c737723746fb86e62">RegionName</a><code> [get]</code></td></tr>
<tr class="memdesc:a736a624c011e954c737723746fb86e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cache region name.  <a href="#a736a624c011e954c737723746fb86e62">More...</a><br/></td></tr>
<tr class="separator:a736a624c011e954c737723746fb86e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f6dde1d2c91233d9df5bd26624541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043f6dde1d2c91233d9df5bd26624541"></a>
<a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache.html">ICache</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Cache</b><code> [get, set]</code></td></tr>
<tr class="separator:a043f6dde1d2c91233d9df5bd26624541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html">NHibernate.Cache.ICacheConcurrencyStrategy</a></td></tr>
<tr class="memitem:aa8fe2554b47f4f4275e8b2b411159797 inherit properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#aa8fe2554b47f4f4275e8b2b411159797">RegionName</a><code> [get]</code></td></tr>
<tr class="memdesc:aa8fe2554b47f4f4275e8b2b411159797 inherit properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cache region name.  <a href="#aa8fe2554b47f4f4275e8b2b411159797">More...</a><br/></td></tr>
<tr class="separator:aa8fe2554b47f4f4275e8b2b411159797 inherit properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa34d87a3fdc23b0f89f353903da3953 inherit properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache.html">ICache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#aaa34d87a3fdc23b0f89f353903da3953">Cache</a><code> [get, set]</code></td></tr>
<tr class="memdesc:aaa34d87a3fdc23b0f89f353903da3953 inherit properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache.html" title="Implementors define a caching algorithm. ">ICache</a> for this strategy to use.  <a href="#aaa34d87a3fdc23b0f89f353903da3953">More...</a><br/></td></tr>
<tr class="separator:aaa34d87a3fdc23b0f89f353903da3953 inherit properties_interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Caches data that is sometimes updated while maintaining the semantics of "read committed" isolation level. If the database is set to "repeatable
read", this concurrency strategy <em>almost</em> maintains the semantics. Repeatable read isolation is compromised in the case of concurrent writes. This is an "asynchronous" concurrency strategy. </p>
<p>If this strategy is used in a cluster, the underlying cache implementation must support distributed hard locks (which are held only momentarily). This strategy also assumes that the underlying cache implementation does not do asynchronous replication and that state has been fully replicated as soon as the lock is released. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_n_hibernate_1_1_cache_1_1_nonstrict_read_write_cache.html" title="Caches data that is sometimes updated without ever locking the cache. If concurrent access to an item...">NonstrictReadWriteCache</a>, <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html" title="Implementors manage transactional access to cached data. ">ICacheConcurrencyStrategy</a></dd></dl>
<p>for a faster algorithm  </p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00023">23</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab74d4e3832dcad4517f42f209253b931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NHibernate.Cache.ReadWriteCache.AfterInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after an item has been inserted (after the transaction completes), instead of calling release(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">version</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This method is used by "asynchronous" concurrency strategies.</p>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#af14bc5aa45d2cd76e34610be5f517411">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00361">361</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a3b61ead673cf1607b4d9df807d71357d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NHibernate.Cache.ReadWriteCache.AfterUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a>&#160;</td>
          <td class="paramname"><em>clientLock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-cache the updated state, if and only if there there are no other concurrent soft locks. Release our lock. </p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00314">314</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a299dd329b28de7a398cf8dbc8623ecef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NHibernate.Cache.ReadWriteCache.Clear </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evict all items from the cache immediately. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_exception.html" title="Represents any exception from an ICache. ">CacheException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#add2569b4045d773433edebbc37bb905a">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00288">288</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a876f7ca2dd7826005ccaf79a8689da36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NHibernate.Cache.ReadWriteCache.Destroy </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up all resources. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_exception.html" title="Represents any exception from an ICache. ">CacheException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a9513c3fc29146a0be1a3177ad47e7095">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00298">298</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a077c21e42cdcb719cd4c96625ecb79f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NHibernate.Cache.ReadWriteCache.Evict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after an item has become stale (before the transaction completes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_exception.html" title="Represents any exception from an ICache. ">CacheException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This method is used by "synchronous" concurrency strategies.</p>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a110c2200a70110d6021432688bd42682">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00396">396</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="af32fddde4d4ea7bfa60cdb75543b60a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">object NHibernate.Cache.ReadWriteCache.Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>txTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not return an item whose timestamp is later than the current transaction timestamp. (Otherwise we might compromise repeatable read unnecessarily.) Do not return an item which is soft-locked. Always go straight to the database instead. </p>
<p>Note that since reading an item from that cache does not actually go to the database, it is possible to see a kind of phantom read due to the underlying row being updated after we have read it from the cache. This would not be possible in a lock-based implementation of repeatable read isolation. It is also possible to overwrite changes made and committed by another transaction after the current transaction read the item from the cache. This problem would be caught by the update-time version-checking, if the data is versioned or timestamped. </p>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a32b4eb6b709c12cef2a77e0947194b82">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00089">89</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a4a92fdf57a1d9ce56c1b5f3288b014e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NHibernate.Cache.ReadWriteCache.Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>currentVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after an item has been inserted (before the transaction completes), instead of calling <a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a077c21e42cdcb719cd4c96625ecb79f0" title="Called after an item has become stale (before the transaction completes). ">Evict()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">currentVersion</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This method is used by "synchronous" concurrency strategies.</p>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a1be424b8fcf79a9f8b0d7a9b9f0964d1">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00401">401</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a33807ee0d8fde2542c5ccd4045a26bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_n_hibernate_1_1_cache_1_1_access_1_1_i_soft_lock.html">ISoftLock</a> NHibernate.Cache.ReadWriteCache.Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop any other transactions reading or writing this item to/from the cache. Send them straight to the database instead. (The lock does time out eventually.) This implementation tracks concurrent locks by transactions which simultaneously attempt to write to an item. </p>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a6b71b738dbb67d637aa23ff123433e19">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00146">146</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a7d9dc40ad88b964bf7852c332485e301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NHibernate.Cache.ReadWriteCache.Put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>txTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IComparer&#160;</td>
          <td class="paramname"><em>versionComparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minimalPut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not add an item to the cache unless the current transaction timestamp is later than the timestamp at which the item was invalidated. (Otherwise, a stale item might be re-added if the database is operating in repeatable read isolation mode.) </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the item was actually put into the cache</dd></dl>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a2a354473284a511d5712ca10c7f24610">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00181">181</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ade68002dda6052479e2faf51f1158bda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NHibernate.Cache.ReadWriteCache.Remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evict an item from the cache immediately (without regard for transaction isolation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_exception.html" title="Represents any exception from an ICache. ">CacheException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#abfea7212cb3c976c79b38e14ab4dbf67">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00293">293</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a7928ddf3c80e5e7b5ec03f209fc32376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NHibernate.Cache.ReadWriteCache.Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_hibernate_1_1_cache_1_1_cache_key.html">CacheKey</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>currentVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>previousVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after an item has been updated (before the transaction completes), instead of calling <a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html#a077c21e42cdcb719cd4c96625ecb79f0" title="Called after an item has become stale (before the transaction completes). ">Evict()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">currentVersion</td><td></td></tr>
    <tr><td class="paramname">previousVersion</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This method is used by "synchronous" concurrency strategies.</p>

<p>Implements <a class="el" href="interface_n_hibernate_1_1_cache_1_1_i_cache_concurrency_strategy.html#a16d7ee28ab9a2cc8b640e45d781862cc">NHibernate.Cache.ICacheConcurrencyStrategy</a>.</p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00406">406</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a736a624c011e954c737723746fb86e62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string NHibernate.Cache.ReadWriteCache.RegionName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cache region name. </p>

<p>Definition at line <a class="el" href="_read_write_cache_8cs_source.html#l00047">47</a> of file <a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/michael/Development/HSA.InfoSys/3rdparty/nhibernate-core/src/NHibernate/Cache/<a class="el" href="_read_write_cache_8cs_source.html">ReadWriteCache.cs</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_n_hibernate.html">NHibernate</a></li><li class="navelem"><a class="el" href="namespace_n_hibernate_1_1_cache.html">Cache</a></li><li class="navelem"><a class="el" href="class_n_hibernate_1_1_cache_1_1_read_write_cache.html">ReadWriteCache</a></li>
    <li class="footer">Generated on Fri Jul 5 2013 02:13:04 for HSA.InfoSys by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
