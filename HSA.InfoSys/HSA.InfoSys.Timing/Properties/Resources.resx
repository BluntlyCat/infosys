<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="COUNTDOWN_TO_STRING" xml:space="preserve">
    <value>Countdown time: [{0}], source: [{1}]</value>
  </data>
  <data name="LOG_COUNTDOWN_INITIALIZE" xml:space="preserve">
    <value>Initialize a new instance of Countdown</value>
  </data>
  <data name="LOG_COUNTDOWN_INITIALIZE_PARAMS" xml:space="preserve">
    <value>Initialize a new instance of Countdown with time [{0}]</value>
  </data>
  <data name="LOG_COUNTDOWN_RESET_VALUES" xml:space="preserve">
    <value>All values cleaned: [{0}, {1}].</value>
  </data>
  <data name="LOG_COUNTDOWN_SET_NEW_REPEAT_TIME" xml:space="preserve">
    <value>New time [{0}] set to repeat.</value>
  </data>
  <data name="LOG_COUNTDOWN_SET_REPEAT_TIME" xml:space="preserve">
    <value>Set new repeat time.</value>
  </data>
  <data name="LOG_COUNTDOWN_START_COUNTDOWN" xml:space="preserve">
    <value>Start new countdown.</value>
  </data>
  <data name="LOG_COUNTDOWN_START_COUNTDOWN_ERROR" xml:space="preserve">
    <value>Could not start countdown, time is not set: [{0}]</value>
  </data>
  <data name="LOG_COUNTDOWN_STOP_COUNTDOWN" xml:space="preserve">
    <value>Stop countdown.</value>
  </data>
  <data name="LOG_COUNTDOWN_THREAD_ENDS" xml:space="preserve">
    <value>Thread left while loop.</value>
  </data>
  <data name="LOG_COUNTDOWN_THREAD_IS_RUNNING" xml:space="preserve">
    <value>Thread is running.</value>
  </data>
  <data name="LOG_REMAIN_TIME_GET_DAYS" xml:space="preserve">
    <value>Get Days [{0}]</value>
  </data>
  <data name="LOG_REMAIN_TIME_GET_HOURS" xml:space="preserve">
    <value>Get Hours [{0}]</value>
  </data>
  <data name="LOG_REMAIN_TIME_GET_MILLISECONDS" xml:space="preserve">
    <value>Get Milliseconds [{0}]</value>
  </data>
  <data name="LOG_REMAIN_TIME_GET_MINUTES" xml:space="preserve">
    <value>Get Minutes [{0}]</value>
  </data>
  <data name="LOG_REMAIN_TIME_GET_SECONDS" xml:space="preserve">
    <value>Get Seconds [{0}]</value>
  </data>
  <data name="LOG_REMAIN_TIME_INITIALIZE" xml:space="preserve">
    <value>Initialize a new instance of RemainTime with TimeSpan [{0}]</value>
  </data>
  <data name="LOG_REMAIN_TIME_TO_STRING" xml:space="preserve">
    <value>Remaining time: [ID: {0} - {1}D : {2}H : {3}m : {4}s]</value>
  </data>
  <data name="LOG_RESET_VALUES" xml:space="preserve">
    <value>Values reset.</value>
  </data>
  <data name="LOG_TIME_RESET_VALUES" xml:space="preserve">
    <value>Values reset [Starttime: {0}, Endtime: {1}, Remaintime: {2}, Type: {3}, Params: {4}, Timestring: {5}].</value>
  </data>
  <data name="LOG_TIME_SET_TIME" xml:space="preserve">
    <value>Set time.</value>
  </data>
  <data name="LOG_TIME_SET_TIME_PARAM_DATETIME" xml:space="preserve">
    <value>Set time with param [{0}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_BEGIN_VALIDATION" xml:space="preserve">
    <value>Validate time [{0}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_EMPTY_STRING" xml:space="preserve">
    <value>Time [{0}] is empty.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_GOT_VALUES_OF_TYPE_DATE" xml:space="preserve">
    <value>Got values from timestring [{0}, {1}, {2}]</value>
  </data>
  <data name="LOG_TIME_VALIDATION_GOT_VALUES_OF_TYPE_TIME" xml:space="preserve">
    <value>Got values from timestring  [{0}, {1}]</value>
  </data>
  <data name="LOG_TIME_VALIDATION_HAS_SEPARATORS" xml:space="preserve">
    <value>Time [{0}] has separators.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_HAS_SEPARATOR_AT_INDEX" xml:space="preserve">
    <value>Time [{0}] has separator at index [{1}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_INVALID_CHARS" xml:space="preserve">
    <value>Time [{0}] has invalid characters.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_INVALID_LENGTH" xml:space="preserve">
    <value>Time [{0}] has invalid length [{1}]</value>
  </data>
  <data name="LOG_TIME_VALIDATION_INVALID_TIME_FORMAT" xml:space="preserve">
    <value>Error while parsing time [{0}], with error:\n[{2}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_INVALID_TYPE_OF_TIME" xml:space="preserve">
    <value>Time has invalid type of {0}</value>
  </data>
  <data name="LOG_TIME_VALIDATION_IS_NOT_VALID" xml:space="preserve">
    <value>Time [{0}] is not valid, error was: [{1}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_IS_NOT_VALID_NO_ERROR" xml:space="preserve">
    <value>Time [{0}] is not valid.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_IS_VALID" xml:space="preserve">
    <value>Time [{0}] is valid.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_NO_SEPARATORS" xml:space="preserve">
    <value>Time [{0}] has no separators.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_NO_SEPARATORS_NEEDED" xml:space="preserve">
    <value>Time [{0}] does not need separators.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_NO_SEPARATOR_AT_INDEX" xml:space="preserve">
    <value>Time [{0}] has no separator at index [{1}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_SET_IF_IN_FUTURE" xml:space="preserve">
    <value>Time [{0}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_SET_TYPE_OF_TIME" xml:space="preserve">
    <value>Set type of time for timestring {0}</value>
  </data>
  <data name="LOG_TIME_VALIDATION_STRING_IS_TYPE_OF" xml:space="preserve">
    <value>Timestring is type of [{0}]</value>
  </data>
  <data name="LOG_TIME_VALIDATION_TIME_IN_PAST" xml:space="preserve">
    <value>Timestring is in past.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_VALID_CHARS" xml:space="preserve">
    <value>Time [{0}] has valid characters.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_VALID_LENGTH" xml:space="preserve">
    <value>Time [{0}] has valid length [{1}].</value>
  </data>
  <data name="LOG_TIME_VALIDATION_WRONG_PLACED_SEPARATOR" xml:space="preserve">
    <value>Time [{0}] has wrong placed separators.</value>
  </data>
  <data name="LOG_TIME_VALIDATION_WRONG_PLACED_SEPARATOR_AT_INDEX" xml:space="preserve">
    <value>Time [{0}] has wrong placed separator at index [{1}].</value>
  </data>
  <data name="SCHEDULER_ON_TICK" xml:space="preserve">
    <value>Remaintime: [{0}].</value>
  </data>
  <data name="TIME_TO_STRING" xml:space="preserve">
    <value>ID: {0}, repeat: {1}, repeat in: {2} hours.</value>
  </data>
  <data name="TIME_VALIDATION_EMPTY_STRING" xml:space="preserve">
    <value>Timestring must not be empty.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_HAS_NO_SEPARATORS" xml:space="preserve">
    <value>Time must have separatos ('.' or ':').</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_INVALID_CHARS" xml:space="preserve">
    <value>Time has invalid characters.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_INVALID_DATE_FORMAT" xml:space="preserve">
    <value>Invalid time format for date</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_INVALID_LENGTH" xml:space="preserve">
    <value>Time has invalid length.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_INVALID_TIME_FORMAT" xml:space="preserve">
    <value>Invalid time format for time</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_INVALID_TYPE_OF_TIME" xml:space="preserve">
    <value>Invalid type of time [{0}]</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_NO_SEPARATOR_AT_INDEX" xml:space="preserve">
    <value>Time has no separators at index {0}.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_TIME_IN_PAST" xml:space="preserve">
    <value>Timestring is in past.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_TIME_NOT_VALID" xml:space="preserve">
    <value>Time is not valid.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_WRONG_PLACED_SEPARATOR" xml:space="preserve">
    <value>Time has wrong placed separator.</value>
  </data>
  <data name="TIME_VALIDATION_ERROR_WRONG_PLACED_SEPARATOR_AT_INDEX" xml:space="preserve">
    <value>Time has wrong placed separator at index [{0}].</value>
  </data>
</root>